Index: Server/src/main/java/com/branch/sikgu/auth/filter/JwtVerificationFilter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.branch.sikgu.auth.filter;\r\n\r\nimport com.branch.sikgu.auth.jwt.JwtTokenizer;\r\nimport com.branch.sikgu.auth.utils.CustomAuthorityUtils;\r\nimport io.jsonwebtoken.ExpiredJwtException;\r\nimport io.jsonwebtoken.security.SignatureException;\r\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\r\nimport org.springframework.security.core.Authentication;\r\nimport org.springframework.security.core.GrantedAuthority;\r\nimport org.springframework.security.core.context.SecurityContextHolder;\r\nimport org.springframework.web.filter.OncePerRequestFilter;\r\n\r\nimport javax.servlet.FilterChain;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.IOException;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\npublic class JwtVerificationFilter extends OncePerRequestFilter {\r\n    private final JwtTokenizer jwtTokenizer;\r\n    private final CustomAuthorityUtils authorityUtils;\r\n\r\n    public JwtVerificationFilter(JwtTokenizer jwtTokenizer,\r\n                                 CustomAuthorityUtils authorityUtils) {\r\n        this.jwtTokenizer = jwtTokenizer;\r\n        this.authorityUtils = authorityUtils;\r\n    }\r\n\r\n    @Override\r\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,\r\n                                    FilterChain filterChain)\r\n            throws ServletException, IOException {\r\n        // System.out.println(\"# JwtVerificationFilter\");\r\n\r\n        try {\r\n            Map<String, Object> claims = verifyJws(request);\r\n            setAuthenticationToContext(claims);\r\n        } catch (SignatureException se) {\r\n            request.setAttribute(\"exception\", se);\r\n        } catch (ExpiredJwtException ee) {\r\n            request.setAttribute(\"exception\", ee);\r\n        } catch (Exception e) {\r\n            request.setAttribute(\"exception\", e);\r\n        }\r\n\r\n        filterChain.doFilter(request, response);\r\n    }\r\n\r\n    @Override\r\n    protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {\r\n        String authorization = request.getHeader(\"Authorization\");\r\n\r\n        return authorization == null || !authorization.startsWith(\"Bearer\");\r\n    }\r\n\r\n    private Map<String, Object> verifyJws(HttpServletRequest request) {\r\n        String jws = request.getHeader(\"Authorization\").replace(\"Bearer \", \"\");\r\n        String base64EncodedSecretKey = jwtTokenizer.encodeBase64SecretKey(jwtTokenizer.getSecretKey());\r\n        Map<String, Object> claims = jwtTokenizer.getClaims(jws, base64EncodedSecretKey).getBody();\r\n\r\n        return claims;\r\n    }\r\n\r\n    private void setAuthenticationToContext(Map<String, Object> claims) {\r\n        String username = (String) claims.get(\"username\");\r\n        List<GrantedAuthority> authorities = authorityUtils.createAuthorities((List)claims.get(\"roles\"));\r\n        Authentication authentication = new UsernamePasswordAuthenticationToken(username, null, authorities);\r\n        SecurityContextHolder.getContext().setAuthentication(authentication);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/branch/sikgu/auth/filter/JwtVerificationFilter.java b/Server/src/main/java/com/branch/sikgu/auth/filter/JwtVerificationFilter.java
--- a/Server/src/main/java/com/branch/sikgu/auth/filter/JwtVerificationFilter.java	(revision ff10b993a059d7a500a5db1e715aa7c1d6930000)
+++ b/Server/src/main/java/com/branch/sikgu/auth/filter/JwtVerificationFilter.java	(date 1684124288643)
@@ -64,7 +64,9 @@
     }
 
     private void setAuthenticationToContext(Map<String, Object> claims) {
-        String username = (String) claims.get("username");
+        // username = 홍길동, 홍길동2로 바꾸는 요청
+        // username = 홍길동, 홍길동2로
+        String username = (String) claims.get("email");
         List<GrantedAuthority> authorities = authorityUtils.createAuthorities((List)claims.get("roles"));
         Authentication authentication = new UsernamePasswordAuthenticationToken(username, null, authorities);
         SecurityContextHolder.getContext().setAuthentication(authentication);
Index: Server/src/main/java/com/branch/sikgu/member/service/MemberService.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.branch.sikgu.member.service;\r\n\r\nimport com.branch.sikgu.auth.jwt.JwtTokenizer;\r\nimport com.branch.sikgu.exception.BusinessLogicException;\r\nimport com.branch.sikgu.exception.ExceptionCode;\r\nimport com.branch.sikgu.exception.HttpStatus;\r\nimport com.branch.sikgu.member.dto.*;\r\nimport com.branch.sikgu.member.entity.Member;\r\nimport com.branch.sikgu.member.mapper.MemberMapper;\r\nimport com.branch.sikgu.member.repository.MemberRepository;\r\nimport com.branch.sikgu.myPage.entity.MyPage;\r\nimport lombok.AllArgsConstructor;\r\nimport org.hibernate.annotations.Check;\r\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\r\nimport org.springframework.security.core.Authentication;\r\nimport org.springframework.security.core.context.SecurityContextHolder;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\n\r\nimport java.time.LocalDateTime;\r\nimport java.util.List;\r\nimport java.util.Optional;\r\n\r\n@Service\r\n@Transactional\r\n@AllArgsConstructor\r\npublic class MemberService {\r\n    private final MemberRepository memberRepository;\r\n    private final MemberMapper memberMapper;\r\n    private final PasswordEncoder passwordEncoder;\r\n    private final JwtTokenizer jwtTokenizer;\r\n\r\n\r\n    // 회원가입 (매퍼를 어느 계층에서 호출하는 게 좋을까요...?)\r\n    public MemberSignUpResponseDto signUp(MemberSignUpRequestDto memberSignUpRequestDto) {\r\n        if (memberRepository.existsByEmail(memberSignUpRequestDto.getEmail())) {\r\n            throw new BusinessLogicException(ExceptionCode.DUPLICATE_EMAIL, HttpStatus.CONFLICT);\r\n        }\r\n        if (memberRepository.existsByNickname(memberSignUpRequestDto.getNickname())) {\r\n            throw new BusinessLogicException(ExceptionCode.DUPLICATE_NICKNAME, HttpStatus.CONFLICT);\r\n        }\r\n\r\n        String encodedPassword = passwordEncoder.encode(memberSignUpRequestDto.getPassword());\r\n        memberSignUpRequestDto.setPassword(encodedPassword);\r\n\r\n        Member member = memberMapper.memberSignUpRequestDtoToMember(memberSignUpRequestDto);\r\n        memberRepository.save(member);\r\n        return memberMapper.memberToMemberSignUpResponseDto(member);\r\n    }\r\n\r\n    // 회원가입시 이메일 중복 체크를 위해 작성했습니다. (AJAX?)\r\n    public boolean checkDuplicateEmail(String email) {\r\n        return memberRepository.existsByEmail(email);\r\n    }\r\n\r\n    // 회원가입시 닉네임 중복 체크를 위해 작성했습니다.\r\n    public boolean checkDuplicateNickname(String nickname) {\r\n        return memberRepository.existsByNickname(nickname);\r\n    }\r\n\r\n\r\n    // 회원정보조회\r\n    public MemberResponseDto findMember(Authentication authentication) {\r\n        return memberMapper.memberToMemberResponseDto(findVerifiedMember(getCurrentMemberId(authentication)));\r\n    }\r\n\r\n    // 회원정보수정\r\n    public MemberResponseDto updateMember(Authentication authentication, MemberUpdateRequestDto memberUpdateRequestDto) {\r\n        Long memberId = getCurrentMemberId(authentication);\r\n        Member member = findVerifiedMember(memberId);\r\n\r\n        Optional.ofNullable(memberUpdateRequestDto.getName())\r\n                .ifPresent(member::setName);\r\n        Optional.ofNullable(memberUpdateRequestDto.getEmail())\r\n                .ifPresent(email -> {\r\n                    if (!member.getEmail().equals(email) && memberRepository.existsByEmail(email)) {\r\n                        throw new BusinessLogicException(ExceptionCode.DUPLICATE_EMAIL, HttpStatus.CONFLICT);\r\n                    }\r\n                    member.setEmail(email);\r\n                });\r\n        Optional.ofNullable(memberUpdateRequestDto.getPassword())\r\n                .ifPresent(password -> member.setPassword(passwordEncoder.encode(password)));\r\n        Optional.ofNullable(memberUpdateRequestDto.getNickname())\r\n                .ifPresent(nickname -> {\r\n                    if (!member.getNickname().equals(nickname) && memberRepository.existsByNickname(nickname)) {\r\n                        throw new BusinessLogicException(ExceptionCode.DUPLICATE_NICKNAME, HttpStatus.CONFLICT);\r\n                    }\r\n                    member.setNickname(nickname);\r\n                });\r\n        Optional.ofNullable(memberUpdateRequestDto.getBirthday())\r\n                .ifPresent(member::setBirthday);\r\n        Optional.ofNullable(memberUpdateRequestDto.getGender())\r\n                .ifPresent(member::setGender);\r\n\r\n        member.setUpdatedAt(LocalDateTime.now());\r\n        memberRepository.save(member);\r\n\r\n        // 회원정보를 수정해도 현재 가지고 있는 Authentication은 로그인 시점의 회원정보를 담고 있어서 회원정보 수정 이후 서비스 이용이 불가\r\n        // 그래서 Authentication의 회원정보를 수정해 줘야 하는데 일반적으로 Principal 속성이 읽기 전용이기 때문에 직접 변경이 불가\r\n        // 결국 새로운 회원정보를 담고있는 Authentication을 만들어서 SecurityContextHolder의 기존 Authentication을 새로운 Authentication로 덮어씌워야 하는 것 같다.\r\n        // ----------------회원의 EMAIL을 고유 식별자로 정해야할 것 같습니다. 변경 불가하게 수정 예정-------------------------\r\n        UsernamePasswordAuthenticationToken newAuthentication = new UsernamePasswordAuthenticationToken(member, authentication.getCredentials(), authentication.getAuthorities());\r\n        SecurityContextHolder.getContext().setAuthentication(newAuthentication);\r\n        return memberMapper.memberToMemberResponseDto(member);\r\n    }\r\n\r\n    // 회원탈퇴\r\n    public void deleteMember(Authentication authentication) {\r\n\r\n        Member findMember = findVerifiedMember(getCurrentMemberId(authentication));\r\n\r\n        findMember.setStatus(Member.MemberStatus.MEMBER_QUIT);\r\n\r\n        memberRepository.save(findMember);\r\n    }\r\n\r\n    public Long getCurrentMemberId(Authentication authentication) {\r\n        Object principal = authentication.getPrincipal();\r\n        if (principal instanceof Member) {\r\n            Member member = (Member) principal;\r\n            return member.getMemberId();\r\n        } else if (principal instanceof String) {\r\n            String username = (String) principal;\r\n            Optional<Member> memberOptional = memberRepository.findByEmail(username);\r\n            if (memberOptional.isPresent()) {\r\n                return memberOptional.get().getMemberId();\r\n            } else {\r\n                throw new IllegalStateException(\"Cannot find member with email: \" + username);\r\n            }\r\n        } else {\r\n            throw new IllegalStateException(\"Unknown principal type: \" + principal.getClass());\r\n        }\r\n    }\r\n\r\n    public Member findMember(String token) {\r\n\r\n        long memberId = jwtTokenizer.getMemberId(token);\r\n\r\n        Member findMember = findVerifiedMember(memberId);\r\n\r\n        if(findMember.getStatus().equals(Member.MemberStatus.MEMBER_QUIT)) {\r\n            throw new BusinessLogicException(ExceptionCode.MEMBER_NOT_FOUND, HttpStatus.NOT_FOUND);\r\n        }\r\n\r\n        return findMember;\r\n    }\r\n\r\n    // 나중에 이 메서드를 사용하고 싶어서 추가해놨어요\r\n    private Member findVerifiedMember(Long memberId) {\r\n        Optional<Member> optionalMember =\r\n                memberRepository.findById(memberId)\r\n                        .filter(member -> member.getStatus() != Member.MemberStatus.MEMBER_QUIT);\r\n        return optionalMember.orElseThrow(() ->\r\n                new BusinessLogicException(ExceptionCode.MEMBER_NOT_FOUND, HttpStatus.NOT_FOUND));\r\n    }\r\n\r\n\r\n    @Transactional(readOnly = true)\r\n    public Member findMember(long memberId) {\r\n        return findVerifiedMember(memberId);\r\n    }\r\n\r\n    public List<Member> findAll() {\r\n        List<Member> members = memberRepository.findAll();\r\n        if (members.isEmpty()) {\r\n            throw new BusinessLogicException(ExceptionCode.MEMBER_NOT_FOUND, HttpStatus.NOT_FOUND);\r\n        }\r\n        return members;\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Server/src/main/java/com/branch/sikgu/member/service/MemberService.java b/Server/src/main/java/com/branch/sikgu/member/service/MemberService.java
--- a/Server/src/main/java/com/branch/sikgu/member/service/MemberService.java	(revision ff10b993a059d7a500a5db1e715aa7c1d6930000)
+++ b/Server/src/main/java/com/branch/sikgu/member/service/MemberService.java	(date 1684124288644)
@@ -31,8 +31,6 @@
     private final PasswordEncoder passwordEncoder;
     private final JwtTokenizer jwtTokenizer;
 
-
-    // 회원가입 (매퍼를 어느 계층에서 호출하는 게 좋을까요...?)
     public MemberSignUpResponseDto signUp(MemberSignUpRequestDto memberSignUpRequestDto) {
         if (memberRepository.existsByEmail(memberSignUpRequestDto.getEmail())) {
             throw new BusinessLogicException(ExceptionCode.DUPLICATE_EMAIL, HttpStatus.CONFLICT);
@@ -41,6 +39,7 @@
             throw new BusinessLogicException(ExceptionCode.DUPLICATE_NICKNAME, HttpStatus.CONFLICT);
         }
 
+
         String encodedPassword = passwordEncoder.encode(memberSignUpRequestDto.getPassword());
         memberSignUpRequestDto.setPassword(encodedPassword);
 
